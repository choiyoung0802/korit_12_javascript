## default function parameter
```js
// 함수 정의
function say(message) {
  if(message != undefined) console.log(message);
  else console.log('매개변수가 넘어오지 않았습니다.');
}

// 함수 호출
say();

/*
이상의 코드에서 함수의 매개변수인 message 값을 전달하지 않으면 message 는 undefined 가 됩니다. 만약에 이 매개변수가 특정 기능을 구현하기 위해 반드시 값이 필요하다면 매개변수 값이 비어있을 때는 오류가 발생하게 될 겁니다. 그래서 say() 내에 값이 있는지 없는지를 체크하는 로직이 필수적으로 요구됩니다.
default function parameter 는 함수 호출 시에 argument 가 아예 없다면 미리 등록되어있는 값을 대입해주는 기능이라고 할 수 있습니다.
*/
function say2(message='매개변수가 넘어오지않았습니다.2') {
  console.log(message);
}
say2();
say2('argument 에 값을 넣었습니다.');
```

## rest parameter
```js
function sum1(x1, x2) {
  let y = x1 + x2;
  return y;
}

console.log(sum1(5, 7));

function sum2(x1, x2, x3, x4) {
  let y = x1 + x2 + x3 + x4;
  return y;
}

console.log(sum2(5, 7, 1, 3));
/*
일반적인 함수 정의는 매개변수를 몇 개 선언할지 미리 지정해두게 됩니다. 2 개 지정하면 무조건 argument 가 2 개 필요하고 4 개 지정하면 4 개의 argument 가 필요하겠네요.
즉, 정해진 argument 를 충족하는 선에서 개발자가 머리 써서 몇 번 호출할지를 고민해야합니다. 범위를 벗어나게 되면 계산 자체가 불가능할 수도 있겠네요.
-> 이상의 문제를 해결하기 위한 것이 Rest Parameter 의 개념입니다. 몇 개의 매개변수가 전달될지 모르는 경우에 사용.
*/
function sum3(...args) { // 매개변수를 이렇게 설정하면, 함수 호출 시 매개변수 개수에 상관없이 할당이 가능하고, 이렇게 지정된 값은 '배열'로 저장됨.
  let total = 0;
  for(let x of args) {
    total += x;
  }
  return total;
}
console.log(sum3(1,2,3,4,5,6,7,8,9,10));
```

## Arrow Function
04_arrow_function.js
```js
// 함수 선언식(가장 기초적인 함수 정의 방식)
function hello1(name) {
  return `Hello ${name}`;
}
// 함수 표현식(종종 쓰는데 화살표 함수랑 합쳐져서 더 많이 쓰입니다.)
const hello2 = function (name) {
  return `오하요 ${name}`;
}

// 화살표 함수의 정의 방식들 -> 람다식 때도 다양한 방법으로 정의했었습니다.

// 모든 소(중)괄호가 다 표기된 화살표 함수
const hello3 = (name) => {return `안녕하세요 ${name}`};

// 매개변수가 하나일 때는 소괄호 생략
const hello4 = name => {return `또 안녕하세요 ${name}`};

// 실행문이 한 줄일 경우에는 중괄호 생략 / 근데 return 문일 경우 return 도 생략
const hello5 = name => `사와디캅 ${name}`;

// 매개변수가 아예 없으면 비어있는 소괄호 사용
const helloEveryone = (name='여러분') => `안녕하세요 ${name}`;
```

## Object Literal Syntax Extension
- JS 에서의 Object 는 key-value property 로 이루어져있는데 기본적으로 key 는 string 자료형.
```js
let fName = 'Jane'; // 지금 얘는 임의적인 데이터 값이고 FE 상에서는
let lName = 'Doe';  // 브라우저의 입력을 받게 될 거기 때문에 변수의 선언과 값 대입이 반 필수적입니다.

let person = {
  firstName : fName,
  lastName : lName
}
console.log(fName);
console.log(person.firstName);
console.log(person['firstName']); // key 가 string 이라는 것을 알 수 있는 예시

/*
Object 상에서는 변수에 할당된 값을 key 로 치환해서 사용하는 것은 불가능합니다.
하지만 object literal syntax extension 을 사용하면 object 의 키로 변수에 할당된 '문자열' 값을 사용할 수 있습니다. 대괄호([]) 를 사용합니다.
*/

let type = 'student';
let score = {
  [type]: 'Jane',
  score: 95
}
console.log(score.score);

console.log(score); // 결과값 : { student: 'Jane', score: 95 }
console.log(score.student);
/*
Object 의 key 를 동적으로 생성가능할 수 있다는 점 : input 태그를 통해서 객체의 key 를 생성할 수 있겠네요.
*/
```

## Spread Operator(spread 연산자)
```js
let arr1 = [4, 5, 6];
let arr2 = [1, 2, 3];
let arr3 = [...arr2, ...arr1];
console.log(arr3); // 결과값 : [ 1, 2, 3, 4, 5, 6 ]
/*
배열, 문자열과 같이 iteration(반복가능자료형) 형태의 데이터를 element 하나하나로 분해해서 사용이 가능하다.
arr1, arr2 는 자료형이 배열임. -> ...arr1 / ...arr2 는 자료형이 배열이 아님.
4, 5, 6 이라는 각각의 element 와 1, 2, 3 이라는 각각의 element 입니다. 즉, 자료형을 착각하기가 너무 쉽습니다.
아까전에 ...args 라고 했을 때 spread 연산자가 도입되어있습니다.
*/

let cd = 'CD';
let alphabets = ['A', 'B', ...cd]; // 그러면 그 와중에 스프레드 연산자의 작성 순서도 중요하네요.
console.log(alphabets);
/*
그럼 alphabets 내부의 element 를 소문자로 바꾸고 싶다면 내부로 들어가서 .toLowerCase()를 적용하면 되겠네요.
*/
// 기본 for 문
for (let i = 0; i < alphabets.length ; i++) {
  console.log(alphabets[i].toLowerCase());
}
// 어떤 for문을 쓸 것인가 in / of
console.log('향상된 for-of 문 사용')
for (let alphabet of alphabets) {
  console.log(alphabet.toLowerCase());
}
```

## Object Destructuring
객체 구조분해
```js
function getPerson() {
  return {
    fName: '영',
    lName: '김',
    age: 20,
    email: 'kim0@test.com',
    city: '부산광역시',
    contry: '대한민국'
  };
}
// 이상의 코드가 있다고 가정했을 때 email 값과 city 의 값을 출력하고 싶다면 어떡해야 할까요?
// 실행 예
/*
해당 지원자는 부산광역시에 살고 있으면 email 은 kim0@test.com 입니다.
*/
let kim0 = getPerson(); // 함수 호출 결과가 object 니까 걔를 변수에 대입한 다음
console.log(`해당 지원자는 ${kim0.city}에 살고 있으며, email 은 ${kim0.email} 입니다.`); // 객체명.key 값을 통해서 해당 value를 불러냄.

let kimEmail = getPerson().email; // 애체오 객체의 특정 key 의 value 만 변수에 저장하고
let kimCity = getPerson().city;
console.log(`해당 지원자는 ${kimCity}에 살고 있으며, email 은 ${kimEmail} 입니다.`); // 콘솔에 찍힐 수 있도록 했음.

// 객체의 추출하고자 하는 key 와 동일한 변수를 선언합니다. {} 내에.
let {email, city} = getPerson(); // 이렇게 쓰면 email 이라고 하는 변수에 getPerson().email 의 value 값이, city 라고 하는 변수에 getPerson().city 의 변수값이 들어갑니다.
console.log(`해당 지원자는 ${city}에 살고 있으며, email 은 ${email} 입니다.`);

function displayFullName({fName, lName}) { // 매개변수가 구조분해되어있음을 {} 로 알 수 있음.
  console.log(`${lName} ${fName}`);
}
displayFullName(getPerson()); // 그러면 argument 로는 key 로 fName / lName 을 가지고 있는 애가 필수적으로 요구됩니다. - 호출시의 argument 와 정의 시의 매개변수의 차이점에 주목할 것. -> React 에서 허구한 날 쓰이기 때문에 꼭 알아둘 것.
```

## Array Destructuring
08_array_destructuring.js

# JavaScript 주요 Web APIs
## LocalStorage / SessionStorage
1. LocalStorage
  - 저장된 데이터를 삭제하기 전까지 영구히 보존됨. 저장되는 모든 데이터는 JS 객체처럼 key-value pair 로 이루어져있습니다. 단, 저장되는 모든 데이터 값은 string 으로만 저장가능합니다. 그래서 이 저장소에 number, object, boolean, array 등과 같은 string 이 아닌 데이터를 저장할 때는 JSON.stringify 를 통해 문자열로 변환하여 저장해야 합니다. 그리고 localStorage 의 데이터를 JS로 읽고 싶다면 JSON.parse() 를 사용하여 객체로 변환해줘야 연산이 가능합니다. - 로컬스토리지는 보안에 위배되지 않고, 영구히 저장해도 상관없는 데이터를 저장할 때 적합함.
    - 사용자가 마지막으로 보고 있는 화면 url 저장.
    - 웹 사이트에서 사용자 테마, 개인화를 제공하는 경우 해당 정보 저장.

```js
// 로컬스토리지에 데이터를 저장하는 예제
if(typeof Storage !== 'undefined') {
  localStorage.setItem('title', '위대한게츠비');
}

const users = [
  {id: 1, name: 'Kim'},
  {id: 2, name: 'Lee'}
]
localStorage.setItem('users', JSON.stringify(users));

console.log(users);
console.log(JSON.stringify(users));

// 다시 받아오는 부분
if (typeof Storage !== 'undefined') {
  console.log(localStorage.getItem('title')); // key 를 통해 value 를 확인합니다.
  console.log(localStorage.getItem('users'));
  // 당연히 'users' key 를 통해서 불러오더라도
  // 결과값 : [{id: 1, name: "Kim"}, {id: 2, name: "Lee"}] 이기는 합니다. 하지만 얘는 기본적으로 string 이기 때문에 users[0].id 와 같은 연산이 불가능합니다.
  console.log(JSON.parse(localStorage.getItem('users')));
}

let users2 = JSON.parse(localStorage.getItem('users'));
let kim = users2[0].name; // 추가 연산을 한 사례
console.log(kim);
```
- 이상의 코드의 주의 사항으로는 localStorage 를 참조해야 하기 때문에 html 파일도 요구됩니다. live server 에서 확인할 것.

2. SessionStorage
- localStorage 는 지우기 전까지 영구 보존됩니다.
- sessionStorage 는 새로고침하면 다 날라갑니다.

12:00 부터 html - css - js 를 합친 예시 하나 작성할 예정.
todolist